# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()),
# деление (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение,
# умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться
# округление значения до целого числа. Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно
# равняться сумме ячеек исходных двух клеток. Вычитание. Участвуют две клетки. Операцию необходимо выполнять только
# если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение. Умножение.
# Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух
# клеток. Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление
# количества ячеек этих двух клеток. В классе необходимо реализовать метод make_order(), принимающий экземпляр класса
# и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам. Метод должен возвращать строку вида
# *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда
# не хватает, то в последний ряд записываются все оставшиеся. Например, количество ячеек клетки равняется 12,
# количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**. Или, количество ячеек клетки
# равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****. Подсказка:
# подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    # По условию, начальное количество клеток и количество ячеек, занимаемых ими, - одинаково.
    # Я не нашёл в условии задачи причины, которая указывала бы на то, что нужно учитывать конечное количество клеток
    # после манипуляций с ними, поэтому в моём решении ведётся только учёт ячеек, которые они заполняют.
    # Соответственно метод make_order упорядочивает именно ячейки в ряду в абстракной пробирке.
    def __init__(self, cells_num):
        self.__cells_num = cells_num

    def __add__(self, other):
        print('\nПроцесс сложения клеток. Смешаем две пробирки: ')
        self.__cells_num = self.__cells_num + other.__cells_num
        return f'В исходной пробирке теперь {self.__cells_num} ячеек.'

    def __sub__(self, other):
        print('\nПроцесс вычитания клеток. Смешаем две пробирки: ')
        if abs(self.__cells_num - other.__cells_num) > 0:
            self.__cells_num = abs(self.__cells_num - other.__cells_num)
            return f'В исходной пробирке теперь {self.__cells_num} ячеек.'
        else:
            return f'В пробирках равное количество клеток. Операция невозможна.'

    def __mul__(self, other):
        print('\nПроцесс умножения клеток. Смешаем две пробирки: ')
        self.__cells_num = self.__cells_num * other.__cells_num
        return f'В исходной пробирке теперь {self.__cells_num} ячеек.'

    def __truediv__(self, other):
        print('\nПроцесс деления клеток. Смешаем две пробирки: ')
        self.__cells_num = int(self.__cells_num / other.__cells_num)
        return f'В исходной пробирке теперь {self.__cells_num} ячеек.'

    def make_order(self, row):
        in_row = f'{"*" * row}\n'
        return f'{in_row * (self.__cells_num // row)}{"*" * (self.__cells_num % row)}'


original_test_tube = Cell(22)
test_tube_2 = Cell(5)
test_tube_3 = Cell(27)
test_tube_4 = Cell(15)
test_tube_5 = Cell(20)
cells_in_row = 8


print(f'Результат: {original_test_tube.__add__(test_tube_2)}')
print(f'Результат: {original_test_tube.__sub__(test_tube_3)}')
print(f'Результат: {original_test_tube.__mul__(test_tube_4)}')
print(f'Результат: {original_test_tube.__truediv__(test_tube_5)}')
print(f'\nПриведём ячейки в порядок. Схема расположения ячеек в пробирке теперь выглядит так:\n'
      f'{original_test_tube.make_order(cells_in_row)}')

# Задача показалась мне достаточно лёгкой. Скорее всего это из-за того, что я не правильно интерпретировал условие.
# Но это уже вопрос к формулировкам методистов, и, как говорится, совсем другая история...
